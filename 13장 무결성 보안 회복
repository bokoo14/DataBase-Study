# 13장 무결성, 보안, 회복

## 1. 무결성
: 데이타의 정확성, 유효성
실제로는 무결성 규칙을 정해 놓음

- 도메인 무결성 규칙
: 주어진 애트리뷰트의 값이 그 애트리뷰트가 정의된 도메인에 속한 값이어야 한다
- 릴레이션 무결성 규칙
: 어느 한 투플이 릴레이션에 삽입 가능한가, 한 릴레이션과 또 다른 릴레이션의 투플들 간의 관계가 적절한가

## SQL에서 무결성 규칙 정의 방법
- 애트리뷰트 제약 조건
constraint 제약조건 이름 check 제약조건 표현 조건식
- 기본 테이블 제약조건
- 주장: 제약조건을 위반하는 연산이 수행되지 않도록 하는 것 
create assertion 이름 check (조건식)
drop assertion 이름;

## 트리거
- 테이블에 어떤 일이 일어나면 자동으로 실행됨
- 즉, 테이블에 삽입, 수정, 삭제 등의 작업이 발생할 때 자동으로 작동
- stored procedure와 비슷한 모양을 갖지만, 직접 실행 시킬 수는 없고, 해당 테이블에 이벤드가 발생한 경우에만 실행됨
- in, out 매개변수를 사용할 수 없음
예) 누군가 A라는 테이블에 행을 고의로 삭제한다면?

- 데이터를 변경할 때마다 실행되는 특별한 저장 프로시저
- 한 데이블과 연관됨
- 삽입, 삭제, 수정 시 자동으로 실행됨
- 저장 프로시저와는 달리 직접 호출될 수 없음
- 하나의 트랜잭션이다

## 트리거 사용 이점 
- DB내 관련 테이블 간의 캐스캐이드(순차적) 변경
- check보다 더 복잡한 데이터 무결성을 강화할 수 있다
- 사용자 정의 에러 메시지 정의 가능
- 비 정규화된 DB환경에서도 사용될 수 있다
- 변경 시 데이터의 전후 상태 비교 가능

## 트리거 사용 시 고려사항
- 트리거는 실행 후, 제약 조건은 실행 전 수행
- 테이블은 어떤 동작에 대해 여러 개의 트리거를 가질 수 있다
- 테이블 소유자 만이 트리거를 생성, 제거할 수 있다
- 트리거는 결과 세트를 리턴할 수 없다
- 트리거는 다중 행 동작을 처리할 수 있다(여러 행에 영향을 미침)

## 트리거 명세 방법
트리거의 예: 조건 만족되면 update명령 자동 실행

## 2. 보안
- 권한이 없는 데이터 엑세스, 악의적인 데이터 파괴 및 유출로부터 DB를 보호하는 것
- DB의 접근 제어는 여러 수준으로 적용 됨
예) 어떤 사용자는 읽기만 할 수 있고, 어떤 사용자는 테이블을 갱신할 수 있음
- 사용자마다 계정과 비밀번호를 부여하고 DB의 특정 부분에 특정 작업만을 허용

## DBMS보안 기능
- DB에 대한 접근을 통제할 수 있는 기능
: 사용자 계정과 암호를 관리함
이를 접근 제어라 함
- 특정 사용자에게 지정된 영역만 접근 통제하는 기능
: DBMS는 이를 위한 권한 관리 모듈을 가지고 있음

- 데이터베이스 관리자(DBA)
: DB시스템 전체에 대한 보안을 관리함
사용자들에게 새로운 계정과 암호를 만들어 줌
어떤 사용자들에게 권한을 부여/회수하는 일
보안 사고 시 DB에 대한 감사 실시

## 데이타베이스 보안 기법(4가지)
1) 권한 부여 테이블 사용
- 사용자 프로파일(user profile)
: 사용자가 접근할 수 있도록 권한이 부여된 데이타 객체와 이 데이타 객체에 대해 수행시킬 수 있는 연산에 관한 정보
- 권한 부여 테이블
: 모든 사용자에 대한 프로파일을 하나의 테이블로 종합 관리
데이타 객체 j에 대해 사용자 i가 수행할 수 있는 연산 권한

2) 뷰 기법
- 뷰의 정의 그 자체가 권한 부여 기법
- 민감한 데이타를 권한이 없는 사용자로부터 은닉
- 약점: 갱신이나 삽입, 삭제와 같은 연산에 제약이 있다


3) grant/revoke기법
- 뷰와는 달리 허용된 데이터에 대해 연산 제한이 가능
- 특정 데이타와 연산을 특정 사용자만 수행할 수 있게 권한 부여를 명세할 수 있다

- 테이블의 생성자
: 테이블에 대한 모든 권한을 가짐
권한 일부를 다른 사용자에게 부여 가능

- DBA
: DBMS에 있는 모든 자원 접근 권한을 가진 사람
따라서, 생성자나 DBA는 GRANT문을 사용하여 권한 일부를 다른 사용자에게 다시 부여 가능

- 권한부여 형식 
grant 권한_리스트 on 객체 to 사용자 [with grant option]
with grant option: 다른 사용자에게 자기가 부여받은 권한 또 다시 부여

- 권한 회수
revoke [grant option for] 권한_리스트 on 객체 from 사용자 {cascade, restrict};
grant option for: 다른 사용자에게 권한을 부여할 수 있게 한 권한 자체를 취소

4) 데이타 암호화(data encryption)
: 허가 받지 않은 사람들이 내용을 쉽게 이해할 수 없도록 은폐시키기 위해 데이타를 암호로 바꾸는 것
- 암호화 시스템
암호화 알고리즘
암호화키
해독 알고리즘

- 평문 P(plaintext): 전송이나 저장해야 될 원시 데이타
- 암호문 C(ciphertext): 암호화된 결과

- 전치 암호화 기법
: 문자들을 일정한 간격으로 나누고, 위치를 변경시키는 것
공백도 하나의 문자로 취급하므로 b로 표시

- 대체 암호화 기법
: 평문의 문자를 다른 문자 정보로 대체
[1단계] 평문을 암호화키와 같은 길이의 블록으로 나눔
[2단계] 대체할 문자 코드를 ♭=00, A=01, B=02, ... , Z=26으로 정하고 해당 정수 코드로 대체
[3단계] 암호화키에 대해서도 2단계 적용
[4단계] 문자별로 합산(블록+암호화키)한 후 mod27 적용
[5단계] 정수 코드에 해당하는 문자로 바꾸어 암호문을 얻음

- DES 기법
: 미국 정부가 일반 대중이 사용할 수 있도록 개발한 암호화 기법
대체 암호화 기법과 순열을 사용함

- 공개키 암호화 기법
: 공개키 암호화
두 개의 키를 사용
암호화 키와 해독 키

## MySQl암호화 기법
: MySQL에서 지원되는 암호화 알고리즘은 AES기법을 사용 
MySQL에서 테이블 암호화 하는 방법은 일반적인 데이블 구문과 동일하며, 마지막에 ENCRYPTION = 'Y'옵션만 추가로 넣으면 됨

## 3. 회복
- 데이타 저장장치
1) 휘발성 저장장치
메인 메모리
시스템 고장 시에 저장된 정보가 유실 됨
2) 비휘발성 저장장치
디스크나 자기 테이프
시스템 고장 시에도 저장된 정보는 손실되지 않음
DB에서 디스크가 많이 사용, 자기 테이프는 백업용으로 사용
3) 안정 저장장치
RAID시스템: 서로 다른 디스크에 블록 사본을 저장

## 데이타베이스 입출력 연신
- 디스크와 메인메모리 사이의 블록 이동

## 장애와 회복 시스템
회복: 장애가 일어났을 때 데이타베이스를 장애 발생 이전의 일관된 상태로 복원시키는 것
일관된 상태: 데이타베이스에 오류나 모순이 없는 상태
장애: 시스템이 정해진 명세대로 작동하지 않는 상태
장애의 원인: 내부적 문제(프로그램 오류, 하드웨어 결함, 소프트웨어의 결함), 외부적 문제(화재, 정전)

## 회복의 개념
- 회복의 기본 원리: 데이타의 중복 저장
- 덤프(log): 주기적으로 DB전체를 다른 저장장치로 복제
- 로그(dump): DB가 변경될 때마다 변경되는 데이터 값의 이전 값과 이후 값을 별도의 로그 파일에 저장해두는 것
       일지라고도 함
- 장애 발생 시 회복을 위해 취할 수 있는 조치: REDO와 UNDO

## REDO(재수행)
- DB내용 자체가 손상된 경우에 사용
- 복사본과 로그 파일을 이용하여 복구하는 것
- 가장 최근에 덤프받은 복사본을 적재시킨 뒤, 이 복사본 이후에 일어난 변경만을 로그를 이용하여 재수행

## UNDO(취소)
- DB내용 자체는 손상되지 않았지만, 변경된 내용에 대한 신뢰성을 잃어버린 경우에 사용
- 로그 화일을 이용하여 모든 변경된 사항들을 취소시킴
- DB를 원래의 상태로 복원시킴

## 데이타베이스 로그를 이용한 회복
- 데이타베이스 로그
: 데이타베이스 변경에 대한 기록으로 가장 많이 사용
  로그를 구성하는 레코드: 트랜잭션 ID, 데이터 항목, 이전 값, 이후 값
- 로그 레코드의 유형

## 즉시 갱신 회복 기법
- 데이타 변경 연산이 발생할 때마다 데이터 변경 결과를 즉시 데이타베이스에 반영하는 것
데이타베이스뿐만 아니라 로그 파일에도 변경 내용을 함께 저장하게 됨
- 트랜잭션 수행 중에 실패 발생하여 트랜잭션을 철회할 때 
로그 파일을 참고하여 UNDO작업을 수행
트랜잭션이 실행되기 전 상태의 데이타 값으로 복원
로그 레코드 값 중에서 이전 값이 사용됨
로그 레코드 형식
- 수행 과정

- 장애가 일어나면 회복 기법은 로그를 참조하여 만일 start레코드만 있고 commit레코드가 없으면 undo
- 만일 start래코드와 commit레코드가 모두 다 있으면 redo

## 지연 갱신의 회복
- 트랜잭션이 부분 완료될 때까지 모든 변경 내용을 로그 파일에만 저장하고, 데이타베이스에 저장하는 것은 지연한다
- 부분 완료 상태에 이르면 로그 파일에 저장된 내용을 데이터베이스에 반영함
- 트랜잭션 실행이 완료 전 장애가 발생하면 로그에 있는 정보는 그냥 버리고 무시
- UNDO연산이 불필요

- REDO연산만 수행되므로 로그 레코드에는 이전 값 필드가 없어도 됨

- 만일 로그에 start레코드만 있고, commit레코드가 없으면 DB에 저장된 내용이 없기 때문에 로그 레코드를 폐기
- 만일 로그에 start레코드와 commit레코드가 모두 다 있으면 redo 연산을 실행하여 로그 값들로 DB를 갱신함

## 검사 시점 회복
- 로그를 이용하는 기법에는 redo, undo되어야 할 트랜잭션을 결정
-> 원칙적으로 로그 전체를 분석
-> 시간이 많이 걸리고, 할 필요없는 redo연산을 반복적으로 해야 하는 문제
-> 검사 시점 방법
: 트랜잭션을 수행하는 동안 일정 간격으로 검사 시점을 만들어 놓는다

## 미디어 회복
- 지금까진 휘발성 저장 장치만 고려
- 비휘발성 저장 장치(디스크)의 내용이 손상되는 경우?
- 미디어(디스크) 회복의 기본 개념
: DB내용 전체를 주기적으로 다른 안전 저장장치에 덤프
미디어 장애가 발생 되었을 때 가장 최근의 덤프를 이용해서 장애 발생 이전의 어떤 일관된 데이타베이스 상태로 복구한 후 
로그를 이용해서 가장 최근의 일관된 상태로 데이타베이스를 복원시킴

- 최근: 디스크 이중화 및 삼중화

