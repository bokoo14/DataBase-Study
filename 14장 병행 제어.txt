#14장 병행 제어

## 1. 트랜잭션
트랜잭션의 예: A게좌에서 100원을 B계좌로 이체하는 트랜잭션
실행 도중 장애 발생: A계좌 100원 인출, B계좌 입금
실패 시 모순 상태 발생

둘 다 수행되거나, 하나라도 수행되지 말아야 함
DBMS는 어느 부분이 트랜잭션인지 알 수 없음
사용자가 트랜잭션을 명시적으로 표시해야 함

트랜잭션? 일련의 연산들의 집합
하나의 논리적 기능을 수행하기 위한 작업의 단위
데아타베이스의 일관된 상태를 또 다른 일관된 상태로 변환시킴
이를 위해 트랜잭션에 포함된 모든 연산은 완전히 처리되거나 하나도 처리되지 않아야 하는 
All or Nothing방식으로 처리되어야 함

## 트랜잭션의 특성(ACID) (4가지)
1) 원자성(Atomaticity)
: 전부 또는 전무 실행만
2) 일관성(Consistency)
: 트랜잭션 실행 후에도 일관성 유지
3) 격리성 (Isolation)
: 트랜잭션 실행 중 연산의 중간 결과에 다른 트랜잭션이 접근할 수 없음
4) 영속성 (Durability)
: 트랜잭션이 일단 성공적으로 실행되면 그 결과는 영구적

## 트랜잭션의 원자성
: A와 B의 합계는 변하지 말아야 함

## 장애 발생 시
T의 실행 전 후가 달라져 일관성 제약을 위반
트랜잭션 설정은 이러한 모순 상태를 방지

## 트랜잭션의 연산
트랜잭션의 원자성을 위한 연산
- 완료(Commit)
: 트랜잭션이 성공적으로 실행되었다는 것을 선언
영속성을 갖도록 보장

- 복귀(Rollback)
: 실패했다는 것을 선언 -> 모순된 데이타베이스 상태
수행한 모든 연산의 결과는 원상 복귀시켜야 함

## 트랜잭션의 상태 (5가지)
- 활동 (Active): 트랜잭션이 실행을 시작
- 부분 완료 (partially commited) : 마지막 명령문을 실행시킨 직후의 상태
- 실패 (failed) : 실행 중에 장애나 오류발생하여 비정상적인 상태
- 철회 (aborted) : 실행을 실패하여 rollback 연산을 수행한 상태, 트랜잭션을 재시작하거나 강제 종료시켜야 함
- 완료 (commited) : 실행을 성공적으로 완료하여 commit 연산을 수행한 상태, DB에 저장되어 연속성 보장

## 병행 제어
: 복사 사용자 DBMS에서는 병행 수행(concurrency)을 지원
프로그램 p1, p2가 인터리브 형태로 병행

## 병행 수행의 문제점 (3가지)
1) 갱신 분실
2) 모순성
3) 연쇄 복귀

## 1) 갱신 분실 (Lost Update)
T1의 갱신을 무효화
T2만 갱신한 결과가 되고, T1의 갱신 연산은 무효가 됨

## 2) 모순성 (inconsistency)
연산 결과는 사용자가 원하는 것이 아님

## 3) 연쇄 복귀 (Cascading Rollback)
T1 : y를 판독하여 갱신하려다 문제 발생, 갱신을 취소하고 원래 상태로 복귀
T2 : 당연히 복귀하여야 하지만 이미 완료된 상태

## 트랜잭션 스케줄
- 직렬 스케줄(serial schedule) : 트랜잭션별로 연속적으로 실행하는 스케줄
문제점 : 값비싼 CPU의 낭비

- 직렬 가능 스케줄 (serializable schedule) : 비직렬 스케줄이지만 정확한 결과를 생성
현실적으로 스케줄의 직렬 가능성 검사는 매우 어렵다

## 병행 제어(concurrency control) 기법
: 로킹(locking), 타임스탬프(timestamp)
- 로킹 기법 : 여러 트랜잭션들이 동일한 항목에 대해 임의적인 병행 접근을 하지 못하게 하는 것
- 타임스탬프 : 타임스탬프 순서에 따라 실행되게 하는 것

## 로킹 기법
- lock의 개념 : 기본적으로 두 개의 연산 lock과 unlock으로 트랜잭션의 데이터 항목을 제어한다
- 로킹 규약 
- 이 규역을 지킨다면 두 개의 트랜잭션이 같은 항목을 동시에 접근하는 경우 없음
- 문제점: read인 경우 병행해도 문제가 없다

1) lock-S : 공용 로크 
트랜잭션 T는 read할 수는 있으나 write할 수는 없다
이때 다른 트랜잭션은 공동 lock을 동시에 걸 수 있다

2) lock-X : 전용 로크
T는 read와 write 모두 할 수 있다
이때 다른 트랜잭션은 어떤 lock도 걸 수 없다

## 2단계 로킹 규약
2단계 로킹 규약 (2PL : two phase locking protocol)
- 확장 단계 (growing phase)
: lock만 할 수 있고 unlock은 할 수 없는 단계
- 축소 단계 (shrinking phase)
: unlock만 수행할 수 있고 lock은 할 수 없는 단계

[정리] 스케줄 내의 모든 트랜잭선들이 2단계 로킹 규약 (2PL)을 준수한다면 그 스케줄은 직렬가능하다.
(즉, 정확한 결과를 생성한다)

## 2PLP로 직렬 가능 스케줄
문제점: 교착상태 (deadlock)

## 교착상태 (deadlock)
아무도 unlock을 할 수 없고 영원히 기다리는 상태가 됨

## 교착상태 해결 방법
회피(avoidance), 예방(prevention), 탐지(detection)
- 회피
: 자원을 할당할 때마다 deadlock이 일어나지 않도록 실시간 알고리즘을 사용(현실성 없음)
- 예방
: 트랜잭션을 실행시키기 전에 필요한 lock을 한꺼번에 모두 요청하여 전부 부여받지 못하면 실행시키지 않음(현실성 없음)
- 탐지
: lock상태를 조사하여 일단 교착상태가 탐지되면 한 트랜잭션을 취소시켜 다시 스케줄을 실행
(취소시킬 트랜잭션은 작업이 가장 적게 수행된 트랜잭션이 설정되는 것이 효율적)

## 회피 방법
교착 상태 회피 방법: 타임 스탬프 이용
타임스탬프는 트랜잭션이 기다려야 할지 복귀해야 할지를 결정하는데 사용됨

- wait-die기법: 트랜잭션 Ti가 이미 트랜잭션 Tj가 lock 한 데이 터 항목을 요구할 때 만일 Ti의 타임스탬프가 Tj의 타임스탬프 보다 작을 경우(즉, Ti가 고참인 경우) Ti를 기다리게(wait) 하고,
그렇지 않으면(즉, Ti가 신참인 경우) Ti는 포기(die)했다가 나중에 같은 스탬프를 가지고 다시 시작한다.

- wound-wait기법: 트랜잭션 Ti가 이미 트랜잭션 Tj가 lock 한 데이터 항목을 요구할 때 만일 Ti의 타임스탬프가 Tj의 타임스탬프보다 작을 경우(즉, Ti가 고참인 경우) Ti는 데 이터를 선점(wound) 한다.
그렇지 않으면(즉, Ti가 신참인 경우) Ti를 기다리게(wait)한다.

## 예방 방법
트랜잭션을 실행시키기 전에 필요한 lock을 한꺼번에 모두 요청하여 전부 부여 받지 못하면 실행시키지 않음

그러나 데이터 요구에 대한 사전 지식을 필요로 하기 때문에 현실성이 없어 보임

데이터 항목이 한꺼번에 lock되기 떄문에 상당한 기간 동안 데이터가 실제로 사용되지 않을 수 있기 때문에 데이터 항목의 활용도가 매우 낮게 됨

## 탐지 방법
교착 상태를 탐지하는 간단한 방법은 대기 그래프(wait for graph)를 사용
이런 방식으로 구축된 대기 그래프에 사이클(Cycle)이 생기면 교착 상태가 발생했다고 판단함

## 로킹 단위 - 기말에 냈음
로킹의 대상이 되는 데이터 객체의 크기 - 병행 제어의 데이터 단위가 됨
로킹 단위가 클수록 병행성 수준이 낮아짐, 병형 제어 기법은 간단
로킹 단위가 작을수록 병행성 수준은 높아짐, lock의 수가 많아져 관리가 복잡해짐

극단적으로 로킹 단위가 데이터베이스 전체가 된다면 병행성은 전혀 없게 됨

적절한 로킹 단위의 결정은 시스템 성능 향상을 위한 하나의 중요한 요소가 될 수 있음
데이터 항목 단위로만 lock를 한다면 모든 항목들에 대해 lock연산을 실행해야 되기 때문에 많은 로킹 연산이 필요함
-> 이러한 비효율성을 해결하기 위해서는 여러 종류(예: 레코드, 화일, 데이터베이스 등)의 로킹 단위를 지원할 수 있는 다중 단위 로킹 기법이 필요함
