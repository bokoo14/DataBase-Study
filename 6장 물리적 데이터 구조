# 6장 물리적 데이터 구조
## 직접 저장 장치
- 탐구시간(seek time): 헤드가 원하는 트랙(실린더)까지 이동하는데 걸리는 시간
- 회전지연시간(rotational delay): 그 트랙에서 원하는 레코드(섹터 또는 블럭)가 헤드 밑에 회전하여 올떄까지 기다리는 시간
***탐구시간이 회전지연시간보다 훨씬 길다

## 데이타의 저장
*****
- 데이타 접근시간: 탐구시간+회전지연시간+데이타전송시간
- 데이타베이스의 중요한 성능 개선의 초점: *****디스크 접근 횟수(I/O)의 최소화
디스크 접근시간은 주기억 장치보다 느리기 때문
*****한 실린더에 저장하면 빠름

## 하드디스크(HDD)
기계적인 회전 디스크를 통해 입/출력 동작 수행
*순차적인 접근은 매우 뛰어남
임의적인 접근에는 취약함

## 플래시 메모리
전기적인 신호 사용
*임의 접근이 뛰어남
소형 정보 기기들이 대중화됨에 따라 플래시 메모리 기반의 SSD(solid state disk)가 보편화됨

## SSD
비휘발성이면서, 접근속도, 저전력, 내구성이 우수
- 단점
덮어 쓰기 연산을 수행할 수 없음
미리 블록 단위로 지우기 연산을 수행한 후 쓰기 연산을 수행
쓰기 연산의 경우 매우 느림
Update-In_Place(덮어쓰기)가 불가능
쓰기 횟수가 제한적임(반영구적이지 못함)

SSD를 효율적으로 사용하기 위해서는 기존의 정보 검색 및 제어 기술들이 바로 적용되기 어렵고, 새로운 DBMS관리 기법 연구가 필요함

## 운영체제 - 파일 관리자, 디스크 관리자
운영체제의 화일 관리자, 디스크 관리자(또는 입출력 서비스)를 이용
- 페이지(page): 입출력의 단위. *****디스크와 주기억 장치 사이에 한번의 디스크 접근으로 데이타가 전송되는 양

## 화일 조직 방법
회일 조직: 데이타베이스의 *물리적 저장 방법
화일 조직 방법: 순차방법(2), 인덱스 방법(5), 해싱 방법(1)
*****
- 순차 방법: 엔트리 순차 화일, 키 순차 화일
- 인덱스 방법: 기본 인덱스, 보조 인덱스, 클러스터링 인덱스, 비클러스터링 인덱스, 다단계 인덱스
- 해싱 방법: 직접 화일

## 순차 방법 - 엔트리 순차 화일, 키 순차 화일
***일괄 처리(batch processing)하는 응용에서 많이 사용
- 엔트리 순차 화일: 레코드가 시스템에 삽입되는 순서로 만들어짐
- 키 순차 화일: 레코드들의 키 값의 크기 순으로 만들어짐

## 인덱스 방법 - 기본 인덱스, 보조 인덱스, 클러스터링 인덱스, 비클러스터링 인덱스, 다단계 인덱스
먼저 인덱스를 찾음 -> 원하는 레코드를 접근
*인덱스 화일과 데이타 화일로 구성
인덱스 화일은 <키값, 주소>쌍으로 구성

- 기본 인덱스
기본키 기반으로 DBMS에서 자동으로 만들어짐
인덱스된 순차 파일이라고도 함
순서로 된 인덱스를 가지고 직접 접근한 후 키 값에 따라 정렬된 순차 데이터 파일을 순차적으로 접근하는 방식

- 보조 인덱스
기본 인덱스 이외의 인덱스를 보조 인덱스라 함
흔히 한 릴레이션에 여러 개의 인덱스를 정의해야 할 필요성이 있음
예) 학과도 빈번히 탐색이 일어날 경우

- 클러스터링 인덱스
*탐색키 값에 따라 정렬된 데이터 파일을 가짐
데이터 파일의 레코드들은 애트리뷰트의 증가하는 순서대로 정렬되어 있음

- 비클러스터링 인덱스
데이터 파일의 레코드들이 탐색키 값과 *무관하게 저장되어 있음
레코드를 검색할 때마다 매번 다른 디스크 블록을 접근함

- 다단계 인덱스
인덱스 자체가 큰 경우, 단일 단계 인덱스에 대해서 다시 인덱스를 정의
원래의 인덱스를 1단계 인덱스, 그 인덱스에 대한 추가 인덱스를 2단계 인덱스라 함
가장 상위 단계의 모든 엔트리들이 한 블록에 들어갈 수 있을 때까지 이런 과정을 반복
마스터 인덱스 = 가장 상위 단계 인덱스

## B-트리
**********
가장 많이 사용
차수가 m인 B-트리의 특성
1) ***비어있거나 높이가 1이상인 m-원 탐색 트리이다
2) 루트와 리프를 제외한 내부 노드는 최소 ceil(m/2), 최대 m개의 서브 트리를 갖는다
3) ***루트는 그 자체가 리프가 아닌 이상 적어도 두 개의 서브트리를 갖는다
4) 모든 리프는 같은 레벨에 있다
5) 리프가 아닌 노드의 키값 수는 그 노드의 서브트리 수보다 하나 적다
6) ***각 리프노드는 최소 ceil(m/2)-1, 최대 m-1개의 키 값을 갖는다
7) 한 노드 안에 있는 키 값들은 오름차순을 유지한다

- 검색
왼쪽 포인터로 지시된 서브트리의 모든 키 값들은 작음
오른쪽 포인터로 지시된 서브트리의 모든 키 값들은 큼
리프노드에는 하부 서브트리에 대한 포인터가 없다

- 삽입
삽입은 항상 리프 노드에서 수행
빈 공간이 있는 경우 단순히 빈 공간에 삽입하면 됨

- 삭제 -> 리프 그대로 삭제, 후행 노드와 자리 바꿔 삭제, 재분배, 합병
삭제할 키가 리프인 경우 그대로 삭제
삭제할 키가 리프가 아닌 노드에 있을 경우 후행 키 값과 일단 자리를 바꾸어 리프노드로 옮긴 후 삭제
만일 삭제 후 남아 있는 키 값을 수가 ceil(m/2)-1에 미달하게 되면 재분배 방법이나 합병 방법을 사용하여 최소 키 값 수를 유지하도록 함

## B+-트리
인덱스 세트와 순차 세트로 구성
- 인덱스 세트: 리프 노드에 있는 키들에 대한 ***경로만 제공. *직접 접근을 지원
- 순차 세트: 리프 노드로 구성되고 모든 키 값들을 저장. 순차 세트는 순차적으로 연결->*순차 접근을 지원. 리프 노드는 내부노드와 상이한 구조를 가짐

m차 B+-트리의 특성
1) ***루트는 0이거나, 2에서 m개 사이의 서브트리를 가짐
2) 루트와 리프를 제외한 모든 내부 노드는 최소 ceil(m/2)개, 최대 m의 서브트리를 가짐
3) 모든 리프 노드는 같은 레벨
4) 리프가 아닌 노드에 있는 키 값의 수는 그 노드의 서브트리 수보다 하나 적음
5) 한 노드 안에 있는 키 값들은 오름차순

***순차 세트를 구성하는 리프 노드는 모두 링크로 연결된 *연결 리스트로 구성

## B-트리와의 차이점
*****
- 인덱스 세트에 있는 키 값은 리프 노드에 있는 키 값을 찾아가는 *경로로만 제공하기 위해 사용
  인댁스 세트에 있는 키 값은 모두 순차 세트에 다시 나타남
- 인덱스 세트의 노드와 순차 세트의 노드는 내부 구조가 서로 다름
  리프 노드: 키 값과 이 키 값을 가진 레코드에 대한 ***주소가 함께 저장
  인덱스 세트: 키 값만 저장
  노드에 저장할 수 있는 원소의 수도 서로 다름
- 순차 세트의 모든 노드가 순차적으로 연결된 연결 리스트
  순차 접근을 효율적으로 지원







