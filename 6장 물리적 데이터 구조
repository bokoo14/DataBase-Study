# 6장 물리적 데이터 구조
## 직접 저장 장치
- 탐구시간(seek time): 헤드가 원하는 트랙(실린더)까지 이동하는데 걸리는 시간
- 회전지연시간(rotational delay): 그 트랙에서 원하는 레코드(섹터 또는 블럭)가 헤드 밑에 회전하여 올떄까지 기다리는 시간
***탐구시간이 회전지연시간보다 훨씬 길다

## 데이타의 저장
*****
- 데이타 접근시간: 탐구시간+회전지연시간+데이타전송시간
- 데이타베이스의 중요한 성능 개선의 초점: *****디스크 접근 횟수(I/O)의 최소화
디스크 접근시간은 주기억 장치보다 느리기 때문
*****한 실린더에 저장하면 빠름

## 하드디스크(HDD)
기계적인 회전 디스크를 통해 입/출력 동작 수행
*순차적인 접근은 매우 뛰어남
임의적인 접근에는 취약함

## 플래시 메모리
전기적인 신호 사용
*임의 접근이 뛰어남
소형 정보 기기들이 대중화됨에 따라 플래시 메모리 기반의 SSD(solid state disk)가 보편화됨

## SSD
비휘발성이면서, 접근속도, 저전력, 내구성이 우수
- 단점
덮어 쓰기 연산을 수행할 수 없음
미리 블록 단위로 지우기 연산을 수행한 후 쓰기 연산을 수행
쓰기 연산의 경우 매우 느림
Update-In_Place(덮어쓰기)가 불가능
쓰기 횟수가 제한적임(반영구적이지 못함)

SSD를 효율적으로 사용하기 위해서는 기존의 정보 검색 및 제어 기술들이 바로 적용되기 어렵고, 새로운 DBMS관리 기법 연구가 필요함

## 운영체제 - 파일 관리자, 디스크 관리자
운영체제의 화일 관리자, 디스크 관리자(또는 입출력 서비스)를 이용
- 페이지(page): 입출력의 단위. *****디스크와 주기억 장치 사이에 한번의 디스크 접근으로 데이타가 전송되는 양

## 화일 조직 방법
회일 조직: 데이타베이스의 *물리적 저장 방법
화일 조직 방법: 순차방법(2), 인덱스 방법(5), 해싱 방법(1)
*****
- 순차 방법: 엔트리 순차 화일, 키 순차 화일
- 인덱스 방법: 기본 인덱스, 보조 인덱스, 클러스터링 인덱스, 비클러스터링 인덱스, 다단계 인덱스
- 해싱 방법: 직접 화일

## 순차 방법 - 엔트리 순차 화일, 키 순차 화일
***일괄 처리(batch processing)하는 응용에서 많이 사용
- 엔트리 순차 화일: 레코드가 시스템에 삽입되는 순서로 만들어짐
- 키 순차 화일: 레코드들의 키 값의 크기 순으로 만들어짐

## 인덱스 방법 - 기본 인덱스, 보조 인덱스, 클러스터링 인덱스, 비클러스터링 인덱스, 다단계 인덱스
먼저 인덱스를 찾음 -> 원하는 레코드를 접근
*인덱스 화일과 데이타 화일로 구성
인덱스 화일은 <키값, 주소>쌍으로 구성

- 기본 인덱스
기본키 기반으로 DBMS에서 자동으로 만들어짐
인덱스된 순차 파일이라고도 함
순서로 된 인덱스를 가지고 직접 접근한 후 키 값에 따라 정렬된 순차 데이터 파일을 순차적으로 접근하는 방식

- 보조 인덱스
기본 인덱스 이외의 인덱스를 보조 인덱스라 함
흔히 한 릴레이션에 여러 개의 인덱스를 정의해야 할 필요성이 있음
예) 학과도 빈번히 탐색이 일어날 경우

- 클러스터링 인덱스
*탐색키 값에 따라 정렬된 데이터 파일을 가짐
데이터 파일의 레코드들은 애트리뷰트의 증가하는 순서대로 정렬되어 있음

- 비클러스터링 인덱스
데이터 파일의 레코드들이 탐색키 값과 *무관하게 저장되어 있음
레코드를 검색할 때마다 매번 다른 디스크 블록을 접근함

- 다단계 인덱스
인덱스 자체가 큰 경우, 단일 단계 인덱스에 대해서 다시 인덱스를 정의
원래의 인덱스를 1단계 인덱스, 그 인덱스에 대한 추가 인덱스를 2단계 인덱스라 함
가장 상위 단계의 모든 엔트리들이 한 블록에 들어갈 수 있을 때까지 이런 과정을 반복
마스터 인덱스 = 가장 상위 단계 인덱스

## B-트리
**********
가장 많이 사용
차수가 m인 B-트리의 특성
1) ***비어있거나 높이가 1이상인 m-원 탐색 트리이다
2) 루트와 리프를 제외한 내부 노드는 최소 ceil(m/2), 최대 m개의 서브 트리를 갖는다
3) ***루트는 그 자체가 리프가 아닌 이상 적어도 두 개의 서브트리를 갖는다
4) 모든 리프는 같은 레벨에 있다
5) 리프가 아닌 노드의 키값 수는 그 노드의 서브트리 수보다 하나 적다
6) ***각 리프노드는 최소 ceil(m/2)-1, 최대 m-1개의 키 값을 갖는다
7) 한 노드 안에 있는 키 값들은 오름차순을 유지한다

- 검색
왼쪽 포인터로 지시된 서브트리의 모든 키 값들은 작음
오른쪽 포인터로 지시된 서브트리의 모든 키 값들은 큼
리프노드에는 하부 서브트리에 대한 포인터가 없다

- 삽입
삽입은 항상 리프 노드에서 수행
빈 공간이 있는 경우 단순히 빈 공간에 삽입하면 됨

- 삭제 -> 리프 그대로 삭제, 후행 노드와 자리 바꿔 삭제, 재분배, 합병
삭제할 키가 리프인 경우 그대로 삭제
삭제할 키가 리프가 아닌 노드에 있을 경우 후행 키 값과 일단 자리를 바꾸어 리프노드로 옮긴 후 삭제
만일 삭제 후 남아 있는 키 값을 수가 ceil(m/2)-1에 미달하게 되면 재분배 방법이나 합병 방법을 사용하여 최소 키 값 수를 유지하도록 함

## B+-트리
인덱스 세트와 순차 세트로 구성
- 인덱스 세트: 리프 노드에 있는 키들에 대한 ***경로만 제공. *직접 접근을 지원
- 순차 세트: 리프 노드로 구성되고 모든 키 값들을 저장. 순차 세트는 순차적으로 연결->*순차 접근을 지원. 리프 노드는 내부노드와 상이한 구조를 가짐

m차 B+-트리의 특성
1) ***루트는 0이거나, 2에서 m개 사이의 서브트리를 가짐
2) 루트와 리프를 제외한 모든 내부 노드는 최소 ceil(m/2)개, 최대 m의 서브트리를 가짐
3) 모든 리프 노드는 같은 레벨
4) 리프가 아닌 노드에 있는 키 값의 수는 그 노드의 서브트리 수보다 하나 적음
5) 한 노드 안에 있는 키 값들은 오름차순

***순차 세트를 구성하는 리프 노드는 모두 링크로 연결된 *연결 리스트로 구성

## B-트리와의 차이점
**********
- 인덱스 세트에 있는 키 값은 리프 노드에 있는 키 값을 찾아가는 *경로로만 제공하기 위해 사용
  인댁스 세트에 있는 키 값은 모두 순차 세트에 다시 나타남
- 인덱스 세트의 노드와 순차 세트의 노드는 내부 구조가 서로 다름
  리프 노드: 키 값과 이 키 값을 가진 레코드에 대한 ***주소가 함께 저장
  인덱스 세트: 키 값만 저장
  노드에 저장할 수 있는 원소의 수도 서로 다름
- 순차 세트의 모든 노드가 순차적으로 연결된 ***연결 리스트
  순차 접근을 효율적으로 지원

- 탐색
- 삽입
- 삭제
  * 리프에서만 삭제(재분배, 합병이 필요 없는 경우)
    인덱스 세트에 있는 키 값은 분리자로 유지 - 키 값을 탐색하는데 분리 키 값으로 사용
  * 재분배: 인덱스 키 값 변경, 트리 구조 유지
  * 합병: 인덱스의 키 값도 삭제

## 해싱 방법
다른 레코드의 참조하지 않고 원하는 목표 레코드를 *직접 접근하는 방법
- 해싱 함수: 어떤 키 값이 주어졌을 때 그 키 값으로부터 그 키 값을 가진 레코드가 저장되어 있는 주소를 계산해 낼 수 있는 기법
- 해시 키: 레코드 주소를 계산하기 위해 사용하는 레코드 키 값
- 해시 주소: 계산 결과로 나온 주소

bucket: 하나의 주소를 갖는 화일의 한 구역. 버킷의 크기는 같은 주소에 포함될 수 있는 레코드 수를 의미
slot: 한 개의 레코드를 저장할 수 있는 공간. n개의 슬롯이 모여 하나의 버킷을 형성
collision: 레코드를 삽입할 때 2개의 상이한 레코드가 똑같은 버킷으로 해싱되는 것

---------------------------------------
실습
-- index 생성
create index idx_student_sname on student(sname);

-- index 삭제
alter table student drop index idx_student_sname;

-- 과목명 열을 primary key로 지정: 기본인덱스/클러스터링 인덱스로 저장. Key_name은 Primary. index_type은 BTREE로 구성
alter table course add constraint pk_name primary key(cname);

-- 단순 보조 인덱스 생성: Non_unique=1 중복을 허용
create index idx_course_year on course(year);

-- 고유 보조 인덱스 생성: Non_unique=0 중복을 허용하지 않음
create unique index idx_course_cid on course(cid);

-- 학년과 과목코드를 조합하여 인덱스 생성: 두 열이 하나의 인덱스로 설정
create index idx_course_year_cid on course(year, cid);

-- index 상태 보기
show index from course;

-- 인덱스 삭제하기: 보조 인덱스를 먼저 삭제하는 것이 좋다
보조 인덱스는 alter table로 삭제해도 된다.
primary key는 drop index로 삭제되지 않고, alter table로만 삭제할 수 있다
drop index idx_course_year on course;
alter table course drop primary key;

클러스터링 인덱스는 한 개만 생성할 수 있고, 보조 인덱스는 테이블 당 여러 개를 생성할 수 있다
많은 데이터가 입력된 후에 alter문으로 primary를 지정하면 인덱스를 구성하는데 많은 시간이 걸릴 수 있다(전체 페이지가 다시 정렬됨
클러스터링 인덱스는 보조 인덱스보다 검색 속도는 빠르지만, 데이터의 입력/수정/삭제는 더 느리다
인덱스의 활용도가 떨어진다면 과감히 삭제해 줄 필요가 있다(성능 저하 문제 때문)

